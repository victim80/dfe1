<div class="eg-content-editor" data-type="imageEditorOneColumn"><div class="column">
  <div class="cropped-image" style="position:relative;overflow: hidden;padding-top: 51.93181818181818%">
    <img style="position: absolute; top: 50%;left: 50%;transform: translate(-50%, -50%);max-width: 100%; max-height: 100%;" src="https://files-storage.easygenerator.com/image/4574977b-e35c-49b6-b657-ddbb4e02cffa.png" alt="" data-src="https://files-storage.easygenerator.com/image/3eab177b-3c8c-41a6-b4c6-0bb52f81d77f.png" data-init="{&quot;w&quot;:880,&quot;h&quot;:457,&quot;y&quot;:0,&quot;x&quot;:0,&quot;defaultScale&quot;:1.0810810810810811,&quot;scale&quot;:0.5405405405405406}">
  </div>
  <div class="row" data-content-type="TextEditor"><p style="text-align:center;height:normal;">Figure 3.33: Architecture of Linux file system</p><p style="text-align:justify;height:normal;">The Linux file system architecture consists of the following two parts:</p><p><strong>User space&nbsp;</strong></p><ul><li>It is the protected memory area where user processes run, and this area contains the available memory.</li></ul><p><strong>Kernel space</strong></p><ul><li>It is the memory space where the system supplies all kernel services through kernel processes. Users can access this space through a system call only. A user process turns into a kernel process only when it executes a system call.</li></ul><p style="text-align:justify;height:normal;">The GNU C Library (glibc) sits between the user space and kernel space and provides the system call interface that connects the kernel to user-space applications.</p><p style="text-align:justify;height:normal;">The virtual file system (VFS) is an abstract layer on top of a complete file system. It allows client applications to access various file systems. Its internal architecture consists of a dispatching layer, which provides file-system abstraction and numerous caches to enhance the performance of file-system operations.</p><p style="text-align:justify;height:normal;">The main objects managed dynamically in the VFS are the dentry and inode objects; these objects are managed in a cached manner to enhance file-system access speed. Once a user opens a file, the dentry cache fills with entries that represent the directory levels, which in turn represent the path. The system also creates an inode for the object that represents the file. The system develops a dentry cache using a hash table and allocates the dentry cache entries from the dentry_cache slab allocator. The system uses a least-recently-used (LRU) algorithm to prune the entries when memory is scarce.</p><p style="text-align:justify;height:normal;">The inode cache acts as two lists and a hash table for quick lookup. The first list defines the used inodes, and the unused ones are positioned in the second list. The hash table also stores the used inodes.</p><p style="text-align: justify;">Device drivers are pieces of code linked with every physical or virtual device and help the OS in managing the device hardware. The functions of the device drivers include setting up hardware, obtaining the related devices in and out of services, obtaining data from hardware and providing it to the kernel, transferring data from the kernel to the device, and identifying and handling device errors.</p></div>
</div></div>